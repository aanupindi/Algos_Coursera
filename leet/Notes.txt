Notes:

Robin Karp Algorithm is used to calculate the hash of strings to help in pattern matching and detecting duplicates.

string s, string pattern.
1. Create a hash for the pattern string.
2. Starting at index 0 of string s, create a hash for the length of pattern and check if hash_s == hash_pattern.
3. if the hash_s == hash_pattern, then check if the strings are actually equal.

Hash Algorithm -> Choose a base number. ex: 101 
                    Reduce the characters to their ASCII values.
                Hash = Sum of {101 ^ ( length of string - i) * ASCII(char)}

This will produce a large number and if each string needs to be added into a hashtable, the value of the hash needs to be reduced by a modulo of the len 
of the hash table.

-> Problem to solve product of all members of an array excluding itself
	It can be solved in 2*O(n) by calculating the product of all the members before i in one processing step and the product of all the members after it 
	in the second processing step. 


ASSERT -> useful method for debbuging during development.
	assert(val) -> if val == 0, this will print an error message on standard output and abort the program.

Header needed: #include <assert.h>
If the macro #NDEBUG is defined, then the assert will be a NO-OP. This will be helpful when converting debug code to non-debug/release code.

SORTING:

1. Selection Sort: Find the minimum element in the current array. Keep it aside and delete it in the current array. Do this until the end of current array. 
   This is at a worst case runtime of O(n^2). Another way of sorting is to do: for each element, find the minimum in the array and replace minimum with current element.
   Here the array is divided into unsorted and sorted elements. There is also no need to have an extra data structure to store the sorted elements.
   
Even though this speedens up the operation, its better to use a more controlled data structure like a heap, priority queue which will reduce the search for min times to logn instead of n.
This in turn will reduce the overall complexity to nlogn

HEAP:

A very efficint data structure to store data in an ordered manner. It helps to maintain data without any pointers.
typedef struct{
item_type q[pq_size+1]; // these are the elements in the queue
int n;			// The number of elements in the queue
}priority_queue;

queue elements are stored in an array starting with index =1.
root element is stored in index =1, left child =2, right =3 and so on.
parent = n/2;
left child = 2k
right child = 2k+1
The positions of each element is known before hand without any need for pointers.


